/*! For license information please see enable3d.ammoPhysics.0.23.0.min.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE"),require("ConvexGeometry")):"function"==typeof define&&define.amd?define(["THREE","ConvexGeometry"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE"),require("ConvexGeometry")):t.ENABLE3D=e(t.THREE,t.ConvexGeometry)}(self,(function(t,e){return(()=>{"use strict";var s={3:function(t,e,s){var o=this&&this.__spreadArray||function(t,e){for(var s=0,o=e.length,i=t.length;s<o;s++,i++)t[i]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var i=s(506),r=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},n=function(t,e,s,o,i){if("function"!=typeof s)throw new TypeError("The listener must be a function");var n=new r(s,o||t,i);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),n]):t._events.get(e).push(n):(t._events.set(e,n),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},m=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return i.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,o=e.length,i=new Array(o);s<o;s++)i[s]=e[s].fn;return i},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,i=[],r=1;r<arguments.length;r++)i[r-1]=arguments[r];if(!this._events.has(t))return!1;var n,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,o([a.context],i)),!0;var m=a.length;for(n=0;n<m;n++)a[n].once&&this.removeListener(t,a[n].fn,void 0,!0),(s=a[n].fn).call.apply(s,o([a[n].context],i));return!0},t.prototype.on=function(t,e,s){return n(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return n(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,o){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var i=this._events.get(t);if(i.fn)i.fn!==e||o&&!i.once||s&&i.context!==s||a(this,t);else{for(var r=0,n=[],m=i.length;r<m;r++)(i[r].fn!==e||o&&!i[r].once||s&&i[r].context!==s)&&n.push(i[r]);n.length?this._events.set(t,1===n.length?n[0]:n):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=m},506:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"},197:function(t,e,s){var o=this&&this.__spreadArray||function(t,e){for(var s=0,o=e.length,i=t.length;s<o;s++,i++)t[i]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var i=s(789),r=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},n=function(t,e,s,o,i){if("function"!=typeof s)throw new TypeError("The listener must be a function");var n=new r(s,o||t,i);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),n]):t._events.get(e).push(n):(t._events.set(e,n),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},m=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return i.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,o=e.length,i=new Array(o);s<o;s++)i[s]=e[s].fn;return i},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,i=[],r=1;r<arguments.length;r++)i[r-1]=arguments[r];if(!this._events.has(t))return!1;var n,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,o([a.context],i)),!0;var m=a.length;for(n=0;n<m;n++)a[n].once&&this.removeListener(t,a[n].fn,void 0,!0),(s=a[n].fn).call.apply(s,o([a[n].context],i));return!0},t.prototype.on=function(t,e,s){return n(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return n(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,o){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var i=this._events.get(t);if(i.fn)i.fn!==e||o&&!i.once||s&&i.context!==s||a(this,t);else{for(var r=0,n=[],m=i.length;r<m;r++)(i[r].fn!==e||o&&!i[r].once||s&&i[r].context!==s)&&n.push(i[r]);n.length?this._events.set(t,1===n.length?n[0]:n):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=m},789:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"},152:t=>{t.exports=e},428:e=>{e.exports=t}},o={};function i(t){var e=o[t];if(void 0!==e)return e.exports;var r=o[t]={exports:{}};return s[t].call(r.exports,r,r.exports,i),r.exports}i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{i.r(r),i.d(r,{AllHitsRaycaster:()=>L,AmmoPhysics:()=>I,Clock:()=>W,ClosestRaycaster:()=>R,ExtendedGroup:()=>l,ExtendedMesh:()=>m,ExtendedObject3D:()=>a,PhysicsLoader:()=>D,Types:()=>t});var t={};i.r(t);const e=new Map,s=(t,s=!1)=>{if(e.has(t)){const s=e.get(t);if(void 0===s)return;if(s>=5)return;e.set(t,s+1)}else e.set(t,1);s?console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55"):console.warn(`%c [enable3d] ${t} `,"background: #222; color: #bada55")};var o=i(197),n=i(428);class a extends n.Object3D{constructor(){super(),this.isExtendedObject3D=!0,this.isGroup=!1,this.vector3=new n.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new n.AnimationMixer(this)),this._animationMixer}get anims(){return{current:this._currentAnimation,add:(t,e)=>this._animsAdd(t,e),get:t=>this._animsGet(t),play:(t,e=500,s=!0)=>this._animsPlay(t,e,s),mixer:this.animationMixer}}get animation(){return s('Please use "anims" instead of "animation"'),this.anims}_animsAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}_animsGet(t){const e=this._animationActions.get(t);return e||s(`Animation(${t}) not found!`),e}_animsPlay(t,e=500,s=!0){const o=this._animationActions.get(t),i=this._animationActions.get(this._currentAnimation);o&&(o.reset(),i&&(o.crossFadeFrom(i,e/1e3,!0),o.clampWhenFinished=!0),s||o.setLoop(n.LoopOnce,0),o.play()),this._currentAnimation=t}setAction(t){s(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)}traverse(t){super.traverse(t)}traverseVisible(t){super.traverseVisible(t)}traverseAncestors(t){super.traverseAncestors(t)}}class m extends n.Mesh{constructor(t,e){super(t,e),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new n.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class l extends n.Group{constructor(){super(),this.isExtendedGroup=!0,this.isMesh=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}}class h{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,o)=>this.pointToPoint(t,e,s,o),hinge:(t,e,s,o)=>this.hinge(t,e,s,o),slider:(t,e,s={},o)=>this.slider(t,e,s,o),spring:(t,e,s={},o)=>this.spring(t,e,s,o),coneTwist:(t,e,s={frameA:{},frameB:{}},o)=>this.coneTwist(t,e,s,o),dof:(t,e,s,o)=>this.dof(t,e,s,o)}}getTransform(t,e,s={x:0,y:0,z:0},o=!1){s=Object.assign({x:0,y:0,z:0},s);const i=new Ammo.btTransform;if(i.setIdentity(),o){const o=(r=t.getWorldTransform().getOrigin(),n=e.getWorldTransform().getOrigin(),a=(r.x()-n.x())/2+s.x,m=(r.y()-n.y())/2+s.y,l=(r.z()-n.z())/2+s.z,new Ammo.btVector3(a,m,l)),i=new Ammo.btTransform;i.setIdentity(),i.setOrigin(o);const h=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return h.op_mul(i),{transformA:h,transformB:i}}return i.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(i),transformB:i};var r,n,a,m,l}lock(t,e,s=!0){const o={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:o,angularUpperLimit:o},s)}fixed(t,e,s=!0){const o=this.getTransform(t.ammo,e.ammo);o.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),o.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(t.ammo,e.ammo,o.transformA,o.transformB);return this.physicsWorld.addConstraint(i,s),i}pointToPoint(t,e,s={},o=!0){const{pivotA:i,pivotB:r}=s,n=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),a=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),m=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,n,a);return this.physicsWorld.addConstraint(m,o),m}hinge(t,e,s={},o=!0){const{pivotA:i,pivotB:r,axisA:n,axisB:a}=s,m=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),l=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),h=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),c=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,m,l,h,c,!0);return this.physicsWorld.addConstraint(d,o),d}slider(t,e,s={},o=!0){const i=this.getTransform(t.ammo,e.ammo),{frameA:r={},frameB:n={},linearLowerLimit:a=0,linearUpperLimit:m=0,angularLowerLimit:l=0,angularUpperLimit:h=0}=s,c=i.transformA.getRotation();c.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformA.setRotation(c);const d=i.transformB.getRotation();d.setEulerZYX(n.x||0,n.y||0,n.z||0),i.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,i.transformA,i.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(m),u.setLowerAngLimit(l),u.setUpperAngLimit(h),this.physicsWorld.addConstraint(u,o),u}spring(t,e,s={},o=!0){const{stiffness:i=50,damping:r=.01,angularLock:n=!1,linearLowerLimit:a={},linearUpperLimit:m={},angularLowerLimit:l={},angularUpperLimit:h={},offset:c={},center:d=!1,enableSpring:u=!0}=s,p=Object.assign({x:0,y:0,z:0},c),y=this.getTransform(t.ammo,e.ammo,p,d),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(m.x||0,m.y||0,m.z||0),g.setLinearUpperLimit(this.tmpBtVector3),n?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(l,h),g.setAngularLowerLimit(this.toAmmoV3(l,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(h,Math.PI)));for(let t=0;t<3;t++)g.enableSpring(t,u),g.setStiffness(t,i),g.setDamping(t,r);return this.physicsWorld.addConstraint(g,o),g}coneTwist(t,e,s,o=!0){const{frameA:i,frameB:r}=s,n=new Ammo.btTransform;n.setIdentity(),n.getOrigin().setValue((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),this.getTransform(t.ammo,e.ammo);const m=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,n,a);return m.setAngularOnly(!0),this.physicsWorld.addConstraint(m,o),m}dof(t,e,s={},o=!0){const{offset:i,center:r=!1}=s,n=Object.assign({x:0,y:0,z:0},i),a=this.getTransform(t.ammo,e.ammo,n,r),m=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:l,linearUpperLimit:h,angularLowerLimit:c,angularUpperLimit:d}=s,u=this.toAmmoV3(l),p=this.toAmmoV3(h),y=this.toAmmoV3(c,-Math.PI),g=this.toAmmoV3(d,Math.PI);return m.setLinearLowerLimit(u),m.setLinearUpperLimit(p),m.setAngularLowerLimit(y),m.setAngularUpperLimit(g),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(g),this.physicsWorld.addConstraint(m,o),m}}var c=i(3);const d="hull",u="manual",p=function(){const t=new n.Vector3,e=new n.Vector3,s=new n.Matrix4;return function(o,i,r,n={}){if(n.type=d,f(n),n.fit===u)return console.warn("cannot use fit: manual with type: hull"),null;const a=V(o,i),m=new Ammo.btVector3,l=new Ammo.btConvexHullShape;l.setMargin(n.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let h=0;for(let t=0;t<o.length;t++)h+=o[t].length/3;const c=n.hullMaxVertices||1e5;h>c&&console.warn(`too many vertices for hull shape; sampling ~${c} from ~${h} vertices`);const p=Math.min(1,c/h);for(let r=0;r<o.length;r++){const n=o[r];s.fromArray(i[r]);for(let i=0;i<n.length;i+=3){const a=r===o.length-1&&i===n.length-3;(Math.random()<=p||a)&&(t.set(n[i],n[i+1],n[i+2]).applyMatrix4(s).sub(e),m.setValue(t.x,t.y,t.z),l.addPoint(m,a))}}let y=l;if(l.getNumVertices()>=100){const t=new Ammo.btShapeHull(l);t.buildHull(n.margin),Ammo.destroy(l),y=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(m),v(y,n,x(r,n)),y}}(),y=function(){const t=new n.Vector3,e=new n.Vector3,s=new n.Matrix4;return function(o,i,r,n,a={}){if(a.type="hacd",f(a),a.fit===u)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const m=V(o,i),l=x(n,a);let h=0,c=0;e.addVectors(m.max,m.min).multiplyScalar(.5);for(let t=0;t<o.length;t++)h+=o[t].length/3,r&&r[t]?c+=r[t].length/3:c+=o[t].length/9;const d=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&d.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&d.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&d.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&d.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&d.SetConcavity(a.concavity);const p=Ammo._malloc(3*h*8),y=Ammo._malloc(3*c*4);d.SetPoints(p),d.SetTriangles(y),d.SetNPoints(h),d.SetNTriangles(c);let g=p/8,b=y/4;for(let n=0;n<o.length;n++){const a=o[n];s.fromArray(i[n]);for(let o=0;o<a.length;o+=3)t.set(a[o+0],a[o+1],a[o+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[g+0]=t.x,Ammo.HEAPF64[g+1]=t.y,Ammo.HEAPF64[g+2]=t.z,g+=3;if(r[n]){const t=r[n];for(let e=0;e<t.length;e++)Ammo.HEAP32[b]=t[e],b++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[b]=t,b++}d.Compute(),Ammo._free(p),Ammo._free(y);const w=d.GetNClusters(),A=[];for(let t=0;t<w;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const s=d.GetNPointsCH(t),o=d.GetNTrianglesCH(t),i=Ammo._malloc(3*s*8),r=Ammo._malloc(3*o*4);d.GetCH(t,i,r);const n=i/8;for(let t=0;t<s;t++){const o=new Ammo.btVector3,i=Ammo.HEAPF64[n+3*t+0],r=Ammo.HEAPF64[n+3*t+1],a=Ammo.HEAPF64[n+3*t+2];o.setValue(i,r,a),e.addPoint(o,t===s-1),Ammo.destroy(o)}v(e,a,l),A.push(e)}return A}}(),g=function(){const t=new n.Vector3,e=new n.Vector3,s=new n.Matrix4;return function(o,i,r,n,a={}){if(a.type="vhacd",f(a),a.fit===u)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const m=V(o,i),l=x(n,a);let h=0,c=0;e.addVectors(m.max,m.min).multiplyScalar(.5);for(let t=0;t<o.length;t++)h+=o[t].length/3,r&&r[t]?c+=r[t].length/3:c+=o[t].length/9;const d=new Ammo.VHACD,p=new Ammo.Parameters;a.hasOwnProperty("resolution")&&p.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&p.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&p.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&p.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&p.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&p.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&p.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&p.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&p.set_m_pca(a.pca),a.hasOwnProperty("mode")&&p.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&p.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&p.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&p.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&p.set_m_oclAcceleration(a.oclAcceleration);const y=Ammo._malloc(3*h*8+3),g=Ammo._malloc(3*c*4);let b=y/8,w=g/4;for(let n=0;n<o.length;n++){const a=o[n];s.fromArray(i[n]);for(let o=0;o<a.length;o+=3)t.set(a[o+0],a[o+1],a[o+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[b+0]=t.x,Ammo.HEAPF64[b+1]=t.y,Ammo.HEAPF64[b+2]=t.z,b+=3;if(r[n]){const t=r[n];for(let e=0;e<t.length;e++)Ammo.HEAP32[w]=t[e],w++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[w]=t,w++}d.Compute(y,3,h,g,3,c,p),Ammo._free(y),Ammo._free(g);const A=d.GetNConvexHulls(),_=[],C=new Ammo.ConvexHull;for(let t=0;t<A;t++){d.GetConvexHull(t,C);const e=C.get_m_nPoints(),s=(C.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(a.margin);for(let t=0;t<e;t++){const o=new Ammo.btVector3,i=C.get_m_points(3*t+0),r=C.get_m_points(3*t+1),n=C.get_m_points(3*t+2);o.setValue(i,r,n),s.addPoint(o,t===e-1),Ammo.destroy(o)}v(s,a,l),_.push(s)}return Ammo.destroy(C),Ammo.destroy(d),_}}(),b=function(){const t=new n.Vector3,e=new n.Vector3,s=new n.Vector3,o=new n.Matrix4;return function(i,r,n,a,m={}){if(m.type="mesh",f(m),m.fit===u)return console.warn("cannot use fit: manual with type: mesh"),null;const l=x(a,m),h=new Ammo.btVector3,c=new Ammo.btVector3,d=new Ammo.btVector3,p=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<i.length;a++){const m=i[a],l=n[a]?n[a]:null;if(o.fromArray(r[a]),l)for(let i=0;i<l.length;i+=3){const r=3*l[i],n=3*l[i+1],a=3*l[i+2];t.set(m[r],m[r+1],m[r+2]).applyMatrix4(o),e.set(m[n],m[n+1],m[n+2]).applyMatrix4(o),s.set(m[a],m[a+1],m[a+2]).applyMatrix4(o),h.setValue(t.x,t.y,t.z),c.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),p.addTriangle(h,c,d,!1)}else for(let i=0;i<m.length;i+=9)t.set(m[i+0],m[i+1],m[i+2]).applyMatrix4(o),e.set(m[i+3],m[i+4],m[i+5]).applyMatrix4(o),s.set(m[i+6],m[i+7],m[i+8]).applyMatrix4(o),h.setValue(t.x,t.y,t.z),c.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),p.addTriangle(h,c,d,!1)}const y=new Ammo.btVector3(l.x,l.y,l.z);let g;return p.setScaling(y),Ammo.destroy(y),g=m.concave?new Ammo.btBvhTriangleMeshShape(p,!0,!0):new Ammo.btConvexTriangleMeshShape(p,!0),g.resources=[p],Ammo.destroy(h),Ammo.destroy(c),Ammo.destroy(d),v(g,m),g}}();function f(t){t.type=t.type||d,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const v=function(t,e,s){},w=function(){const t=new n.Matrix4;return function(e,s,o){parseInt(n.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld),(new n.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((i=>{const r=new n.Matrix4;i.isMesh&&(s.includeInvisible||i.el&&i.el.object3D.visible||i.visible)&&(i===e?r.identity():(i.updateWorldMatrix(!0),r.multiplyMatrices(t,i.matrixWorld)),o(i.geometry.isBufferGeometry?i.geometry.attributes.position.array:i.geometry.vertices,r.elements,i.geometry.index?i.geometry.index.array:null))}))}}(),x=function(){const t=new n.Matrix4;return function(e,s={}){const o=new n.Vector3(1,1,1);return"all"===s.fit&&(t.fromArray(e),o.setFromMatrixScale(t)),o}}(),V=(new n.Vector3,function(t,e){const s=new n.Box3;let o=1/0,i=1/0,r=1/0,a=-1/0,m=-1/0,l=-1/0;return s.min.set(0,0,0),s.max.set(0,0,0),A(t,e,(t=>{t.x<o&&(o=t.x),t.y<i&&(i=t.y),t.z<r&&(r=t.z),t.x>a&&(a=t.x),t.y>m&&(m=t.y),t.z>l&&(l=t.z)})),s.min.set(o,i,r),s.max.set(a,m,l),s}),A=function(){const t=new n.Vector3,e=new n.Matrix4;return function(s,o,i){for(let r=0;r<s.length;r++){e.fromArray(o[r]);for(let o=0;o<s[r].length;o+=3)t.set(s[r][o],s[r][o+1],s[r][o+2]).applyMatrix4(e),i(t)}}}(),_=class{constructor(){this._defaultMaterial=new n.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}};var C=function(t,e){var s={};for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&e.indexOf(o)<0&&(s[o]=t[o]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(o=Object.getOwnPropertySymbols(t);i<o.length;i++)e.indexOf(o[i])<0&&Object.prototype.propertyIsEnumerable.call(t,o[i])&&(s[o[i]]=t[o[i]])}return s};class M{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new _}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:o=0,y:i=0,z:r=0}=s;let a;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":a=new n.Line(t,e);break;case"PointsMaterial":a=new n.Points(t,e);break;default:a=new m(t,e)}return a.position.set(o,i,r),a.castShadow=a.receiveShadow=!0,a}makeExtrude(t,e){const{x:s,y:o,z:i,name:r,shape:a,autoCenter:m=!0,breakable:l=!1}=t,h=C(t,["x","y","z","name","shape","autoCenter","breakable"]),{depth:c=1,bevelEnabled:d=!1}=h,u=new n.ExtrudeBufferGeometry(a,Object.assign({depth:c,bevelEnabled:d},h)),p=this.addMaterial(e),y=this.createMesh(u,p,{x:s,y:o,z:i});return m&&y.geometry.center(),y.name=r||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.PlaneBufferGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1),h=this.addMaterial(e);h.side=n.DoubleSide;const c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="plane",c}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.SphereBufferGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0),h=this.addMaterial(e),c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="sphere",c}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.BoxBufferGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0),h=this.addMaterial(e),c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="box",c}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(n.MathUtils.degToRad(90)),this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.CylinderBufferGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0),h=this.addMaterial(e),c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="cylinder",c}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.ConeBufferGeometry(m.radius||1,m.height||1,m.radiusSegments||8,m.heightSegments||1,m.openEnded||!1,m.thetaStart||0,m.thetaLength||2*Math.PI),h=this.addMaterial(e),c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="cone",c}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:o,z:i,name:r,breakable:a=!1}=t,m=C(t,["x","y","z","name","breakable"]),l=new n.TorusBufferGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0),h=this.addMaterial(e),c=this.createMesh(l,h,{x:s,y:o,z:i});return c.name=r||`body_id_${c.id}`,c.shape="torus",c}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let o;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":o=new n.MeshBasicMaterial(t.basic);break;case"normal":o=new n.MeshNormalMaterial(t.normal);break;case"standard":o=new n.MeshStandardMaterial(t.standard);break;case"lambert":o=new n.MeshLambertMaterial(t.lambert);break;case"phong":o=new n.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?o=new n.MeshPhysicalMaterial(t.physical):(s("You need to pass parameters to the physical material. (Fallback to default material)"),o=this.defaultMaterial.get());break;case"toon":o=new n.MeshToonMaterial(t.toon);break;case"line":o=new n.LineBasicMaterial(t.line);break;case"points":o=new n.PointsMaterial(t.points);break;case"custom":o=t.custom||this.defaultMaterial.get();break;default:o=this.defaultMaterial.get()}return o}}class B extends c.Events{addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(o=>{var i,r;const{bodies:n,event:a}=o;(null===(i=n[0])||void 0===i?void 0:i.name)&&(null===(r=n[1])||void 0===r?void 0:r.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(n[0].name===t.name&&n[1].name===e.name||n[1].name===t.name&&n[0].name===e.name)&&s(a)})))}}var P=i(152);const S=t=>new(window.THREE&&window.THREE.ConvexGeometry?window.THREE.ConvexGeometry:P.ConvexGeometry)(t),T=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new n.Line3,this.tempPlane1=new n.Plane,this.tempPlane2=new n.Plane,this.tempPlane_Cut=new n.Plane,this.tempCM1=new n.Vector3,this.tempCM2=new n.Vector3,this.tempVector3=new n.Vector3,this.tempVector3_2=new n.Vector3,this.tempVector3_3=new n.Vector3,this.tempVector3_P0=new n.Vector3,this.tempVector3_P1=new n.Vector3,this.tempVector3_P2=new n.Vector3,this.tempVector3_N0=new n.Vector3,this.tempVector3_N1=new n.Vector3,this.tempVector3_AB=new n.Vector3,this.tempVector3_CB=new n.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var O;T.prototype={constructor:T,prepareBreakableObject:function(t,e,s,o,i){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var r=t.userData.ammoPhysicsData;r.mass=e,r.velocity=s.clone(),r.angularVelocity=o.clone(),r.breakable=i},subdivideByImpact:function(t,e,s,o,i){var r=[],n=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),n.setFromCoplanarPoints(e,t.position,this.tempVector3);var m=i+o,l=this;return function i(h,c,d,u){if(Math.random()<.05*u||u>m)r.push(h);else{var p=Math.PI;0===u?(a.normal.copy(n.normal),a.constant=n.constant):u<=o?(p=(d-c)*(.2+.6*Math.random())+c,l.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,l.tempVector3,l.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,l.tempVector3_2.copy(e).sub(h.position).applyAxisAngle(s,p).add(h.position),l.tempVector3_3.copy(s).add(h.position),a.setFromCoplanarPoints(h.position,l.tempVector3_3,l.tempVector3_2)),l.cutByPlane(h,a,l.tempResultObjects);var y=l.tempResultObjects.object1,g=l.tempResultObjects.object2;y&&i(y,c,p,u+1),g&&i(g,p,d,u+1)}}(t,0,2*Math.PI,0),r},cutByPlane:function(t,e,o){var i=t.geometry,r=i.attributes.position.array,a=i.attributes.normal.array,m=r.length/3,l=m/3,h=i.getIndex();function c(t,e){var s=3*t+e;return h?h[s]:s}h&&(l=(h=h.array).length/3);for(var d=[],u=[],p=this.smallDelta,y=m*m,g=0;g<y;g++)this.segments[g]=!1;var b=this.tempVector3_P0,f=this.tempVector3_P1,v=this.tempVector3_N0,w=this.tempVector3_N1;for(g=0;g<l-1;g++){var x=c(g,0),V=c(g,1),A=c(g,2);v.set(a[x],a[x]+1,a[x]+2);for(var _=g+1;_<l;_++){var C=c(_,0),M=c(_,1),B=c(_,2);w.set(a[C],a[C]+1,a[C]+2),1-v.dot(w)<p&&(x===C||x===M||x===B?V===C||V===M||V===B?(this.segments[x*m+V]=!0,this.segments[V*m+x]=!0):(this.segments[A*m+x]=!0,this.segments[x*m+A]=!0):V!==C&&V!==M&&V!==B||(this.segments[A*m+V]=!0,this.segments[V*m+A]=!0))}}var P=this.tempPlane_Cut;for(t.updateMatrix(),T.transformPlaneToLocalSpace(e,t.matrix,P),g=0;g<l;g++)for(var O=c(g,0),E=c(g,1),k=c(g,2),D=0;D<3;D++){var z=0===D?O:1===D?E:k,j=0===D?E:1===D?k:O;if(!this.segments[z*m+j]){this.segments[z*m+j]=!0,this.segments[j*m+z]=!0,b.set(r[3*z],r[3*z+1],r[3*z+2]),f.set(r[3*j],r[3*j+1],r[3*j+2]);var R=0;(L=P.distanceToPoint(b))>p?(R=2,u.push(b.clone())):L<-p?(R=1,d.push(b.clone())):(R=3,d.push(b.clone()),u.push(b.clone()));var L,W=0;if((L=P.distanceToPoint(f))>p?(W=2,u.push(f.clone())):L<-p?(W=1,d.push(f.clone())):(W=3,d.push(f.clone()),u.push(f.clone())),1===R&&2===W||2===R&&1===W){this.tempLine1.start.copy(b),this.tempLine1.end.copy(f);var I=new n.Vector3;if(void 0===(I=P.intersectLine(this.tempLine1,I)))return console.error("Internal error: segment does not intersect plane."),o.segmentedObject1=null,o.segmentedObject2=null,0;d.push(I),u.push(I.clone())}}}var F=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var H=0,N=d.length;if(N>0){for(g=0;g<N;g++)this.tempCM1.add(d[g]);for(this.tempCM1.divideScalar(N),g=0;g<N;g++)(Q=d[g]).sub(this.tempCM1),H=Math.max(H,Q.x,Q.y,Q.z);this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var G=0,U=u.length;if(U>0){for(g=0;g<U;g++)this.tempCM2.add(u[g]);for(this.tempCM2.divideScalar(U),g=0;g<U;g++){var Q;(Q=u[g]).sub(this.tempCM2),G=Math.max(G,Q.x,Q.y,Q.z)}this.tempCM2.add(t.position)}var $=null,q=null,X=0;if(N>4)try{($=new n.Mesh(S(d),t.material)).position.copy(this.tempCM1),$.quaternion.copy(t.quaternion),$.userData=t.userData,this.prepareBreakableObject($,F,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*H>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}if(U>4)try{(q=new n.Mesh(S(u),t.material)).position.copy(this.tempCM2),q.quaternion.copy(t.quaternion),q.userData=t.userData,this.prepareBreakableObject(q,F,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*G>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}return o.object1=$,o.object2=q,X}},T.transformFreeVector=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[4]*o+r[8]*i,t.y=r[1]*s+r[5]*o+r[9]*i,t.z=r[2]*s+r[6]*o+r[10]*i,t},T.transformFreeVectorInverse=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*i,t.y=r[4]*s+r[5]*o+r[6]*i,t.z=r[8]*s+r[9]*o+r[10]*i,t},T.transformTiedVectorInverse=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*i-r[12],t.y=r[4]*s+r[5]*o+r[6]*i-r[13],t.z=r[8]*s+r[9]*o+r[10]*i-r[14],t},T.transformPlaneToLocalSpace=(O=new n.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var o=T.transformTiedVectorInverse(t.coplanarPoint(O),e);T.transformFreeVectorInverse(s.normal,e),s.constant=-o.dot(s.normal)});const E=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){console.error(t.message)}return!1})(),k=(t,e)=>{((t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error(`failed to load ${t}`)},s.async=!0,s.src=t,document.head.appendChild(s)})(E?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))},D=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),k(t,(()=>{Ammo().then((()=>{e()}))}))},z=(t,e)=>{e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s))}))}))};class j{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class R{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class L{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}z(R,[j,class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),z(L,[j,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getHitPointWorld(){return s("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let s=e.size()-1;s>=0;s--){const o=Ammo.castObject(e.at(s),Ammo.btRigidBody);t.push(o.threeObject)}return t}}]);class W{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}class I extends c.Events{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new n.Euler,this.tmpQuaternion=new n.Quaternion,this.tmpVector3=new n.Vector3,this.tmpVector3a=new n.Vector3,this.tmpMatrix4=new n.Matrix4,this.tmpMatrix4a=new n.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new n.Vector3,this.impactPoint=new n.Vector3,this.impactNormal=new n.Vector3,"headless"!==t&&(this.defaultMaterial=new _),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const s=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==s?void 0:s.ammo))return;let o=s.ammo.threeObject;const i=o.name;if(i&&o&&(null===(e=null==o?void 0:o.body)||void 0===e?void 0:e.ammo)){o.body.isSoftBody?this.physicsWorld.removeSoftBody(o.body.ammo):this.physicsWorld.removeRigidBody(o.body.ammo),o.body.destructor(),o.body=void 0,o.hasBody=!1,delete s.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===i&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&o&&(o=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new T,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new B,this.factory=new M(this.scene),this.shapes=new class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),o=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(s,o),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}}(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new h(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new class{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||1;const o=32768&this.debugDrawMode||!1,i=s.maxBufferSize||1e6;this.geometry=new n.BufferGeometry;const r=new Float32Array(3*i),a=new Float32Array(3*i);this.geometry.setAttribute("position",new n.BufferAttribute(r,3).setUsage(n.StaticDrawUsage)),this.geometry.setAttribute("color",new n.BufferAttribute(a,3).setUsage(n.StaticDrawUsage)),this.index=0;const m=new n.LineBasicMaterial({vertexColors:!0,depthTest:!o});this.mesh=new n.LineSegments(this.geometry,m),o&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const o=Ammo.HEAPF32,i=o[(s+0)/4],r=o[(s+4)/4],n=o[(s+8)/4],a=o[(t+0)/4],m=o[(t+4)/4],l=o[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,m,l),this.geometry.attributes.color.setXYZ(this.index++,i,r,n);const h=o[(e+0)/4],c=o[(e+4)/4],d=o[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,c,d),this.geometry.attributes.color.setXYZ(this.index++,i,r,n)}drawContactPoint(t,e,s,o,i){const r=Ammo.HEAPF32,n=r[(i+0)/4],a=r[(i+4)/4],m=r[(i+8)/4],l=r[(t+0)/4],h=r[(t+4)/4],c=r[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,h,c),this.geometry.attributes.color.setXYZ(this.index++,n,a,m);const d=r[(e+0)/4]*s,u=r[(e+4)/4]*s,p=r[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,l+d,h+u,c+p),this.geometry.attributes.color.setXYZ(this.index++,n,a,m)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}}(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),o=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(e,o,i,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),o=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver,r=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(e,o,i,t,r)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,t.name=`${e.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t],s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){const t=this.worldTransform.getOrigin(),s=this.worldTransform.getRotation(),o=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+o.x,t.y()+o.y,t.z()+o.z),this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(n.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const s=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const o=this.physicsWorld.getDispatcher(),i=o.getNumManifolds();for(let r=0;r<i;r++){const i=o.getManifoldByIndexInternal(r),n=i.getNumContacts(),a=Ammo.castObject(i.getBody0(),Ammo.btRigidBody),m=Ammo.castObject(i.getBody1(),Ammo.btRigidBody),l=a.threeObject,h=m.threeObject;if(!l||!h)continue;if(""===a.name&&""===m.name)continue;const c=null===(t=l.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=h.body)||void 0===e?void 0:e.checkCollisions,u=l.body.breakable,p=h.body.breakable,y=l.body.fractureImpulse,g=h.body.fractureImpulse,b=c||d,f=u||p;if(void 0===l.fragmentDepth&&(l.fragmentDepth=0),void 0===h.fragmentDepth&&(h.fragmentDepth=0),!b&&!f)continue;let v=!1,w=0,x="start";for(let t=0;t<n;t++){const e=i.getContactPoint(t);if(e.getDistance()<=0){v=!0;const t=e.getAppliedImpulse(),o=e.get_m_positionWorldOnB(),i=e.get_m_normalWorldOnB();if(c||d){const t=[l.name,h.name].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find((t=>t.combinedName===e))&&(x="collision"),s.find((t=>t.combinedName===e))||(s.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[l,h],event:x}))}t>=w&&(w=t,(u||p)&&(this.impactPoint.set(o.x(),o.y(),o.z()),this.impactNormal.set(i.x(),i.y(),i.z())));break}}if(!v)continue;if(!f)continue;const V=2;if(this.emptyV3.set(0,0,0),l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},h.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:m},u&&w>y&&l.fragmentDepth<V){const t=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=a.getLinearVelocity(),o=a.getAngularVelocity(),i=t[s];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(i,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}if(p&&w>g&&h.fragmentDepth<V){const t=this.convexBreaker.subdivideByImpact(h,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=m.getLinearVelocity(),o=m.getAngularVelocity(),i=t[s];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(i,h)}this.objectsToRemove[this.numObjectsToRemove++]=h}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((t=>{const{combinedName:e}=t;if(!s.find((t=>t.combinedName===e))){const t=e.split("__"),s=this.rigidBodies.find((e=>e.name===t[0])),o=this.rigidBodies.find((e=>e.name===t[1])),i="end";s&&o&&this.collisionEvents.emit("collision",{bodies:[s,o],event:i})}})),this.earlierDetectedCollisions=[...s]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():s("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new R(this):new L(this)}}prepareThreeObjectForCollisionShape(t,e={}){var o,i;const{autoCenter:r=!1}=e,n={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let a="unknown";const m=(null===(o=t.geometry)||void 0===o?void 0:o.type)||"unknown";/box/i.test(m)?a="box":/cone/i.test(m)?a="cone":/cylinder/i.test(m)?a="cylinder":/extrude/i.test(m)?a="extrude":/plane/i.test(m)?a="plane":/sphere/i.test(m)?a="sphere":/torus/i.test(m)&&(a="torus");let l=Object.assign(Object.assign({},n),null===(i=null==t?void 0:t.geometry)||void 0===i?void 0:i.parameters);return e.shape?(l=Object.assign(Object.assign({},n),e),a=e.shape):t.shape&&(a=t.shape),Object.keys(l).forEach((t=>{void 0===l[t]&&n[t]&&(l[t]=n[t])})),r&&t.geometry.center(),"cylinder"===a&&(l.radius=e.radius||l.radiusTop),"extrude"===a&&(a="hacd"),"mesh"!==a&&"convex"!==a||(a="convexMesh"),"concave"===a&&(a="concaveMesh"),"unknown"===a&&(s(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),a="box"),{shape:a,params:l,object:t}}createCollisionShape(t,e,s){const o=(null==s?void 0:s.quaternion)?null==s?void 0:s.quaternion:new n.Quaternion(0,0,0,1),{axis:i="y"}=e,r=new Ammo.btVector3,a=null==s?void 0:s.geometry;s&&(null==a?void 0:a.isGeometry)&&(s.geometry=(new n.BufferGeometry).fromGeometry(a));let m,l={};switch(-1!==this.complexShapes.indexOf(t)&&(l=(t=>{const e=(new n.Matrix4).elements,s=[],o=[],i=[];return w(t,{},((t,e,r)=>{s.push(t),o.push(e),i.push(r)})),{vertices:s,matrices:o,indexes:i,matrixWorld:e}})(s)),t){case"box":r.setValue(e.width/2,e.height/2,e.depth/2),m=new Ammo.btBoxShape(r);break;case"sphere":m=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(i){case"y":r.setValue(e.radius,e.height/2,e.radius),m=new Ammo.btCylinderShape(r);break;case"x":r.setValue(e.height/2,e.radius,e.radius),m=new Ammo.btCylinderShapeX(r);break;case"z":r.setValue(e.radius,e.radius,e.height/2),m=new Ammo.btCylinderShapeZ(r)}break;case"cone":switch(i){case"y":m=new Ammo.btConeShape(e.radius,e.height);break;case"x":m=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":m=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(i){case"y":m=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":m=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":m=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":m=((t,e)=>{const{radius:s=1,tube:o=.4,tubularSegments:i=8}=t,r=Math.PI,n=i,a=Math.sqrt(2*o*o-2*o*o*Math.cos(2*r/n)),m=new Ammo.btVector3(o,r/n+.5*a,o),l=new Ammo.btCylinderShape(m);l.setMargin(.05);const h=new Ammo.btCompoundShape,c=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<n;t++){const e=2*t*r/n,s=d.rotate(c,e),o=new Ammo.btTransform;u.setRotation(c,e+Math.PI/2),o.setIdentity(),o.setOrigin(s),o.setRotation(u),h.addChildShape(o,l)}return h})(e,o);break;case"plane":m=b(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":m=p(l.vertices,l.matrices,l.matrixWorld,e);break;case"hacd":m=y(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"vhacd":m=g(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"convexMesh":m=b(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"concaveMesh":m=b(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(r);const{x:h,y:c,z:d}=e;return(h||c||d)&&(m.offset={x:h||0,y:c||0,z:d||0}),Array.isArray(m)&&(m=this.mergeCollisionShapesToCompoundShape(m)),m}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const s=t._tmp;if(s){const{pos:o,quat:i,scale:r,margin:n}=s,a=this.applyPosQuatScaleMargin(t,o,i,r,n);e.addChildShape(a,t)}else{const s=new Ammo.btTransform;s.setIdentity(),e.addChildShape(s,t)}})),e}addExisting(t,e={}){const{hasBody:o}=t;if(o)return void s(`Object "${t.name}" already has a physical body!`);const i=new n.Vector3,r=new n.Quaternion,a=new n.Vector3;t.getWorldPosition(i),t.getWorldQuaternion(r),t.getWorldScale(a);const m="1"===(e.collisionFlags||0).toString(2).slice(-1),l="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:h="unknown",compound:c=[],mass:d=(m||l?0:1),collisionFlags:u=0,collisionGroup:p=1,collisionMask:y=-1,offset:g,breakable:b=!1,addChildren:f=!0,margin:v=.01,ignoreScale:w=!1,fractureImpulse:x=1}=e;if(w&&a.set(1,1,1),c.length>=1){const e=c.map((t=>this.createCollisionShape(t.shape,t))),s=this.mergeCollisionShapesToCompoundShape(e),o=this.applyPosQuatScaleMargin(s,i,r,a,v),n=this.collisionShapeToRigidBody(s,o,d,l);return this.addRigidBodyToWorld(t,n,u,p,y,g),t.body.breakable=b,t.body.fractureImpulse=x,void(t.body.ignoreScale=w)}const V=[];if("unknown"!==h||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);V.push(o)}if("unknown"===h&&f&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s._tmp={pos:t.position.clone(),quat:t.quaternion.clone(),scale:t.scale.clone(),margin:v},V.push(s)}})),0===V.length){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);V.push(o)}const A=1===V.length?V[0]:this.mergeCollisionShapesToCompoundShape(V),_=this.applyPosQuatScaleMargin(A,i,r,a,v),C=this.collisionShapeToRigidBody(A,_,d,l);this.addRigidBodyToWorld(t,C,u,p,y,g),t.body.breakable=b,t.body.fractureImpulse=x,t.body.ignoreScale=w}addRigidBodyToWorld(t,e,s,i,r,a){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,i,r);const m=Object.values(e)[0];t.name||(t.name=`object-${t.id}`),e.name=t.name,t.body=new class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new n.Euler,this.tmpQuaternion=new n.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new o.Events,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new o.Events)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:s,event:o}=e;s[0].name===this.name?t(s[1],o):s[1].name===this.name&&t(s[0],o)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const o=this.tmpEuler.set(t,e,s),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(o),this.tmpBtQuaternion.setValue(0,0,0,1);const r=this.tmpBtQuaternion;r.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(r)}get rotation(){let t,e,s;const o=this.physics.worldTransform.getRotation();let i=this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w());i.w>1&&(i=i.normalize());const r=2*Math.acos(i.w),n=Math.sqrt(1-i.w*i.w);return n<.001?(t=i.x,e=i.y,s=i.z):(t=i.x/n,e=i.y/n,s=i.z/n),{x:t*r,y:e*r,z:s*r}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}(this,e),t.hasBody=!0,t.ptr=m,e.threeObject=t,a&&(t.body.offset=Object.assign({x:0,y:0,z:0},a)),t.body.setCollisionFlags(s)}applyPosQuatScaleMargin(t,e=new n.Vector3,s=new n.Quaternion,o=new n.Vector3,i=.01){t.setMargin(i);const r=new Ammo.btQuaternion(0,0,0,1);r.setValue(s.x,s.y,s.z,s.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(e.x,e.y,e.z),a.setRotation(r),Ammo.destroy(r);const m=new Ammo.btVector3(o.x,o.y,o.z);return t.setLocalScaling(m),Ammo.destroy(m),a}collisionShapeToRigidBody(t,e,s,o){const i=new Ammo.btDefaultMotionState(e),r=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,r);const n=new Ammo.btRigidBodyConstructionInfo(s,i,t,r),a=new Ammo.btRigidBody(n);return(s>0||o)&&a.setActivationState(4),a}}})(),r})()}));
//# sourceMappingURL=enable3d.ammoPhysics.0.23.0.min.js.map